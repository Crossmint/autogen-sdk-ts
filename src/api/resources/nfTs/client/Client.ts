/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments";
import * as core from "../../../../core";
import * as Crossmint from "../../../index";
import * as serializers from "../../../../serialization/index";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index";

export declare namespace NfTs {
    interface Options {
        environment?: core.Supplier<environments.CrossmintEnvironment | string>;
        apiKey: core.Supplier<string>;
        /** Override the Authorization header */
        authorization: core.Supplier<string>;
        /** Override the X-CLIENT-ID header */
        clientId: core.Supplier<string>;
        fetcher?: core.FetchFunction;
    }

    interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the Authorization header */
        authorization?: string;
        /** Override the X-CLIENT-ID header */
        clientId?: string;
    }
}

export class NfTs {
    constructor(protected readonly _options: NfTs.Options) {}

    /**
     * Mint multiple NFTs with a single call and deliver them to a web3 wallet or an email address
     *
     * **API scope required** `nfts.create`
     *
     * @param {string} collectionId - This is the identifier for the collection related to the request. Every project has default collections: `default-solana` and `default-polygon`.
     *
     *                                The [create-collection](/api-reference/minting/collection/create-collection) API will result in collections with UUID formatted `collectionId`.
     *                                **Example:** `9c82ef99-617f-497d-9abb-fd355291681b`
     *
     *                                The [create-collection-idempotent](/api-reference/minting/collection/create-collection-idempotent) API allows you to specify an arbitrary identifier during the intitial request.
     *                                **Example:** `your-custom-identifer`
     * @param {Crossmint.BatchMintNftRequest} request
     * @param {NfTs.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Crossmint.BadRequestError}
     * @throws {@link Crossmint.ForbiddenError}
     * @throws {@link Crossmint.ServiceUnavailableError}
     *
     * @example
     *     await client.nfTs.batchMintNft("default-solana", {
     *         nfts: [{}]
     *     })
     */
    public async batchMintNft(
        collectionId: string,
        request: Crossmint.BatchMintNftRequest,
        requestOptions?: NfTs.RequestOptions
    ): Promise<Crossmint.BatchMintResponse> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.CrossmintEnvironment.Default,
                `2022-06-09/collections/${encodeURIComponent(collectionId)}/nfts/`
            ),
            method: "POST",
            headers: {
                "X-CLIENT-ID": await core.Supplier.get(this._options.clientId),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "crossmint",
                "X-Fern-SDK-Version": "0.0.6",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
            },
            contentType: "application/json",
            requestType: "json",
            body: serializers.BatchMintNftRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return serializers.BatchMintResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                skipValidation: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Crossmint.BadRequestError(_response.error.body);
                case 403:
                    throw new Crossmint.ForbiddenError(_response.error.body);
                case 503:
                    throw new Crossmint.ServiceUnavailableError(_response.error.body);
                default:
                    throw new errors.CrossmintError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CrossmintError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CrossmintTimeoutError();
            case "unknown":
                throw new errors.CrossmintError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Get a list of all the NFTs in a given collection.
     *
     * **API scope required**: `nfts.read`
     *
     * @param {string} collectionId - This is the identifier for the collection related to the request. Every project has default collections: `default-solana` and `default-polygon`.
     *
     *                                The [create-collection](/api-reference/minting/collection/create-collection) API will result in collections with UUID formatted `collectionId`.
     *                                **Example:** `9c82ef99-617f-497d-9abb-fd355291681b`
     *
     *                                The [create-collection-idempotent](/api-reference/minting/collection/create-collection-idempotent) API allows you to specify an arbitrary identifier during the intitial request.
     *                                **Example:** `your-custom-identifer`
     * @param {Crossmint.MintStatusListRequest} request
     * @param {NfTs.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Crossmint.BadRequestError}
     * @throws {@link Crossmint.ForbiddenError}
     * @throws {@link Crossmint.NotFoundError}
     * @throws {@link Crossmint.ServiceUnavailableError}
     *
     * @example
     *     await client.nfTs.mintStatusList("default-solana", {
     *         page: 1.1,
     *         perPage: 20
     *     })
     */
    public async mintStatusList(
        collectionId: string,
        request: Crossmint.MintStatusListRequest,
        requestOptions?: NfTs.RequestOptions
    ): Promise<Crossmint.NftObjectEvm[]> {
        const { page, perPage } = request;
        const _queryParams: Record<string, string | string[] | object | object[]> = {};
        _queryParams["page"] = page.toString();
        if (perPage != null) {
            _queryParams["perPage"] = perPage.toString();
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.CrossmintEnvironment.Default,
                `2022-06-09/collections/${encodeURIComponent(collectionId)}/nfts`
            ),
            method: "GET",
            headers: {
                "X-CLIENT-ID": await core.Supplier.get(this._options.clientId),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "crossmint",
                "X-Fern-SDK-Version": "0.0.6",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
            },
            contentType: "application/json",
            queryParameters: _queryParams,
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return serializers.nfTs.mintStatusList.Response.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                skipValidation: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Crossmint.BadRequestError(_response.error.body);
                case 403:
                    throw new Crossmint.ForbiddenError(_response.error.body);
                case 404:
                    throw new Crossmint.NotFoundError(_response.error.body);
                case 503:
                    throw new Crossmint.ServiceUnavailableError(_response.error.body);
                default:
                    throw new errors.CrossmintError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CrossmintError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CrossmintTimeoutError();
            case "unknown":
                throw new errors.CrossmintError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Mint your NFTs and deliver them to a web3 wallet or an email address
     *
     * **API scope required**: `nfts.create`
     *
     * @param {string} collectionId - This is the identifier for the collection related to the request. Every project has default collections: `default-solana` and `default-polygon`.
     *
     *                                The [create-collection](/api-reference/minting/collection/create-collection) API will result in collections with UUID formatted `collectionId`.
     *                                **Example:** `9c82ef99-617f-497d-9abb-fd355291681b`
     *
     *                                The [create-collection-idempotent](/api-reference/minting/collection/create-collection-idempotent) API allows you to specify an arbitrary identifier during the intitial request.
     *                                **Example:** `your-custom-identifer`
     * @param {Crossmint.MintNftRequest} request
     * @param {NfTs.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Crossmint.BadRequestError}
     * @throws {@link Crossmint.ForbiddenError}
     * @throws {@link Crossmint.NotFoundError}
     * @throws {@link Crossmint.ServiceUnavailableError}
     *
     * @example
     *     await client.nfTs.mintNft("default-solana", {
     *         metadata: {
     *             name: "Crossmint Example NFT",
     *             image: "https://www.crossmint.com/assets/crossmint/logo.png",
     *             description: "My NFT created via the mint API!"
     *         }
     *     })
     */
    public async mintNft(
        collectionId: string,
        request: Crossmint.MintNftRequest,
        requestOptions?: NfTs.RequestOptions
    ): Promise<Crossmint.MintNftResponse> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.CrossmintEnvironment.Default,
                `2022-06-09/collections/${encodeURIComponent(collectionId)}/nfts`
            ),
            method: "POST",
            headers: {
                "X-CLIENT-ID": await core.Supplier.get(this._options.clientId),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "crossmint",
                "X-Fern-SDK-Version": "0.0.6",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
            },
            contentType: "application/json",
            requestType: "json",
            body: serializers.MintNftRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return serializers.MintNftResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                skipValidation: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Crossmint.BadRequestError(_response.error.body);
                case 403:
                    throw new Crossmint.ForbiddenError(_response.error.body);
                case 404:
                    throw new Crossmint.NotFoundError(_response.error.body);
                case 503:
                    throw new Crossmint.ServiceUnavailableError(_response.error.body);
                default:
                    throw new errors.CrossmintError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CrossmintError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CrossmintTimeoutError();
            case "unknown":
                throw new errors.CrossmintError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Mint your SFTs and deliver them to a web3 wallet or an email address
     *
     * **API scope required**: `nfts.create`
     *
     * @param {string} collectionId - This is the identifier for the collection related to the request. Every project has default collections: `default-solana` and `default-polygon`.
     *
     *                                The [create-collection](/api-reference/minting/collection/create-collection) API will result in collections with UUID formatted `collectionId`.
     *                                **Example:** `9c82ef99-617f-497d-9abb-fd355291681b`
     *
     *                                The [create-collection-idempotent](/api-reference/minting/collection/create-collection-idempotent) API allows you to specify an arbitrary identifier during the intitial request.
     *                                **Example:** `your-custom-identifer`
     * @param {Crossmint.MintSftRequest} request
     * @param {NfTs.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Crossmint.BadRequestError}
     * @throws {@link Crossmint.ForbiddenError}
     * @throws {@link Crossmint.NotFoundError}
     * @throws {@link Crossmint.ServiceUnavailableError}
     *
     * @example
     *     await client.nfTs.mintSft("default-solana", {
     *         templateId: "silver-pass",
     *         recipient: "email:testy@crossmint.io:polygon"
     *     })
     */
    public async mintSft(
        collectionId: string,
        request: Crossmint.MintSftRequest,
        requestOptions?: NfTs.RequestOptions
    ): Promise<Crossmint.MintSftResponse> {
        const { idempotencyKey, ..._body } = request;
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.CrossmintEnvironment.Default,
                `2022-06-09/collections/${encodeURIComponent(collectionId)}/sfts`
            ),
            method: "POST",
            headers: {
                "X-CLIENT-ID": await core.Supplier.get(this._options.clientId),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "crossmint",
                "X-Fern-SDK-Version": "0.0.6",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                "x-idempotency-key": idempotencyKey != null ? idempotencyKey : undefined,
                ...(await this._getCustomAuthorizationHeaders()),
            },
            contentType: "application/json",
            requestType: "json",
            body: serializers.MintSftRequest.jsonOrThrow(_body, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return serializers.MintSftResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                skipValidation: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Crossmint.BadRequestError(_response.error.body);
                case 403:
                    throw new Crossmint.ForbiddenError(_response.error.body);
                case 404:
                    throw new Crossmint.NotFoundError(_response.error.body);
                case 503:
                    throw new Crossmint.ServiceUnavailableError(_response.error.body);
                default:
                    throw new errors.CrossmintError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CrossmintError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CrossmintTimeoutError();
            case "unknown":
                throw new errors.CrossmintError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Get the status and associated information for a mint operation.
     *
     * **API scope required**: `nfts.read`
     *
     * @param {string} collectionId - This is the identifier for the collection related to the request. Every project has default collections: `default-solana` and `default-polygon`.
     *
     *                                The [create-collection](/api-reference/minting/collection/create-collection) API will result in collections with UUID formatted `collectionId`.
     *                                **Example:** `9c82ef99-617f-497d-9abb-fd355291681b`
     *
     *                                The [create-collection-idempotent](/api-reference/minting/collection/create-collection-idempotent) API allows you to specify an arbitrary identifier during the intitial request.
     *                                **Example:** `your-custom-identifer`
     * @param {string} id - Unique ID of the minted NFT returned in the mint response
     * @param {NfTs.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Crossmint.BadRequestError}
     * @throws {@link Crossmint.ForbiddenError}
     * @throws {@link Crossmint.NotFoundError}
     * @throws {@link Crossmint.ServiceUnavailableError}
     *
     * @example
     *     await client.nfTs.mintStatus("default-solana", "id")
     */
    public async mintStatus(
        collectionId: string,
        id: string,
        requestOptions?: NfTs.RequestOptions
    ): Promise<Crossmint.MintStatusSolana200> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.CrossmintEnvironment.Default,
                `2022-06-09/collections/${encodeURIComponent(collectionId)}/nfts/${encodeURIComponent(id)}`
            ),
            method: "GET",
            headers: {
                "X-CLIENT-ID": await core.Supplier.get(this._options.clientId),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "crossmint",
                "X-Fern-SDK-Version": "0.0.6",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return serializers.MintStatusSolana200.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                skipValidation: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Crossmint.BadRequestError(_response.error.body);
                case 403:
                    throw new Crossmint.ForbiddenError(_response.error.body);
                case 404:
                    throw new Crossmint.NotFoundError(_response.error.body);
                case 503:
                    throw new Crossmint.ServiceUnavailableError(_response.error.body);
                default:
                    throw new errors.CrossmintError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CrossmintError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CrossmintTimeoutError();
            case "unknown":
                throw new errors.CrossmintError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * This pathway allows you to mint NFTs and guarantee idempotency
     * to ensure you never double mint for the same NFT.
     *
     * **API scope required**: `nfts.create`
     *
     * @param {string} collectionId - This is the identifier for the collection related to the request. Every project has default collections: `default-solana` and `default-polygon`.
     *
     *                                The [create-collection](/api-reference/minting/collection/create-collection) API will result in collections with UUID formatted `collectionId`.
     *                                **Example:** `9c82ef99-617f-497d-9abb-fd355291681b`
     *
     *                                The [create-collection-idempotent](/api-reference/minting/collection/create-collection-idempotent) API allows you to specify an arbitrary identifier during the intitial request.
     *                                **Example:** `your-custom-identifer`
     * @param {string} id - Custom ID of the NFT, which is used as an idempotency key
     * @param {Crossmint.MintNftIdempotentRequest} request
     * @param {NfTs.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Crossmint.BadRequestError}
     * @throws {@link Crossmint.ForbiddenError}
     * @throws {@link Crossmint.NotFoundError}
     * @throws {@link Crossmint.ServiceUnavailableError}
     *
     * @example
     *     await client.nfTs.mintNftIdempotent("default-solana", "my-idempotency-key", {
     *         recipient: "email:testy@crossmint.io:polygon",
     *         metadata: {
     *             name: "Crossmint Example NFT",
     *             image: "https://www.crossmint.com/assets/crossmint/logo.png",
     *             description: "My NFT created via the mint API!"
     *         }
     *     })
     */
    public async mintNftIdempotent(
        collectionId: string,
        id: string,
        request: Crossmint.MintNftIdempotentRequest,
        requestOptions?: NfTs.RequestOptions
    ): Promise<Crossmint.MintNftIdempotentResponse> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.CrossmintEnvironment.Default,
                `2022-06-09/collections/${encodeURIComponent(collectionId)}/nfts/${encodeURIComponent(id)}`
            ),
            method: "PUT",
            headers: {
                "X-CLIENT-ID": await core.Supplier.get(this._options.clientId),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "crossmint",
                "X-Fern-SDK-Version": "0.0.6",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
            },
            contentType: "application/json",
            requestType: "json",
            body: serializers.MintNftIdempotentRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return serializers.MintNftIdempotentResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                skipValidation: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Crossmint.BadRequestError(_response.error.body);
                case 403:
                    throw new Crossmint.ForbiddenError(_response.error.body);
                case 404:
                    throw new Crossmint.NotFoundError(_response.error.body);
                case 503:
                    throw new Crossmint.ServiceUnavailableError(_response.error.body);
                default:
                    throw new errors.CrossmintError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CrossmintError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CrossmintTimeoutError();
            case "unknown":
                throw new errors.CrossmintError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Burn a minted NFT.
     *
     * **API scope required**: `nfts.delete`
     *
     * @param {string} collectionId - This is the identifier for the collection related to the request. Every project has default collections: `default-solana` and `default-polygon`.
     *
     *                                The [create-collection](/api-reference/minting/collection/create-collection) API will result in collections with UUID formatted `collectionId`.
     *                                **Example:** `9c82ef99-617f-497d-9abb-fd355291681b`
     *
     *                                The [create-collection-idempotent](/api-reference/minting/collection/create-collection-idempotent) API allows you to specify an arbitrary identifier during the intitial request.
     *                                **Example:** `your-custom-identifer`
     * @param {string} id - Unique ID of the minted NFT returned in the mint response
     * @param {NfTs.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Crossmint.BadRequestError}
     * @throws {@link Crossmint.ForbiddenError}
     * @throws {@link Crossmint.NotFoundError}
     * @throws {@link Crossmint.ServiceUnavailableError}
     *
     * @example
     *     await client.nfTs.burnNft("default-solana", "id")
     */
    public async burnNft(
        collectionId: string,
        id: string,
        requestOptions?: NfTs.RequestOptions
    ): Promise<Crossmint.BurnNftResponse> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.CrossmintEnvironment.Default,
                `2022-06-09/collections/${encodeURIComponent(collectionId)}/nfts/${encodeURIComponent(id)}`
            ),
            method: "DELETE",
            headers: {
                "X-CLIENT-ID": await core.Supplier.get(this._options.clientId),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "crossmint",
                "X-Fern-SDK-Version": "0.0.6",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return serializers.BurnNftResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                skipValidation: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Crossmint.BadRequestError(_response.error.body);
                case 403:
                    throw new Crossmint.ForbiddenError(_response.error.body);
                case 404:
                    throw new Crossmint.NotFoundError(_response.error.body);
                case 503:
                    throw new Crossmint.ServiceUnavailableError(_response.error.body);
                default:
                    throw new errors.CrossmintError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CrossmintError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CrossmintTimeoutError();
            case "unknown":
                throw new errors.CrossmintError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Edit a minted NFT's metadata on IPFS.
     *
     * If you are using a custom baseURI, invoking this will overwrite the specific tokenURI for the edited token.
     *
     * **API scope required**: `nfts.update`
     *
     * @param {string} collectionId - This is the identifier for the collection related to the request. Every project has default collections: `default-solana` and `default-polygon`.
     *
     *                                The [create-collection](/api-reference/minting/collection/create-collection) API will result in collections with UUID formatted `collectionId`.
     *                                **Example:** `9c82ef99-617f-497d-9abb-fd355291681b`
     *
     *                                The [create-collection-idempotent](/api-reference/minting/collection/create-collection-idempotent) API allows you to specify an arbitrary identifier during the intitial request.
     *                                **Example:** `your-custom-identifer`
     * @param {string} id - Unique ID of the minted NFT returned in the mint response
     * @param {Crossmint.EditNftRequest} request
     * @param {NfTs.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Crossmint.BadRequestError}
     * @throws {@link Crossmint.ForbiddenError}
     * @throws {@link Crossmint.NotFoundError}
     * @throws {@link Crossmint.ServiceUnavailableError}
     *
     * @example
     *     await client.nfTs.editNft("default-solana", "id", {
     *         metadata: {
     *             name: "Crossmint Example NFT",
     *             image: "https://www.crossmint.com/assets/crossmint/logo.png",
     *             description: "My NFT created via the mint API!"
     *         }
     *     })
     */
    public async editNft(
        collectionId: string,
        id: string,
        request: Crossmint.EditNftRequest,
        requestOptions?: NfTs.RequestOptions
    ): Promise<Crossmint.EditNftResponse> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.CrossmintEnvironment.Default,
                `2022-06-09/collections/${encodeURIComponent(collectionId)}/nfts/${encodeURIComponent(id)}`
            ),
            method: "PATCH",
            headers: {
                "X-CLIENT-ID": await core.Supplier.get(this._options.clientId),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "crossmint",
                "X-Fern-SDK-Version": "0.0.6",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
            },
            contentType: "application/json",
            requestType: "json",
            body: serializers.EditNftRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return serializers.EditNftResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                skipValidation: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Crossmint.BadRequestError(_response.error.body);
                case 403:
                    throw new Crossmint.ForbiddenError(_response.error.body);
                case 404:
                    throw new Crossmint.NotFoundError(_response.error.body);
                case 503:
                    throw new Crossmint.ServiceUnavailableError(_response.error.body);
                default:
                    throw new errors.CrossmintError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CrossmintError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CrossmintTimeoutError();
            case "unknown":
                throw new errors.CrossmintError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Burn a minted NFT using a Crossmint NFT locator.
     *
     * **API scope required**: `nfts.delete`
     *
     * @param {string} locator - The locator of the NFT, which includes the blockchain, contract address, and token ID.
     * @param {NfTs.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Crossmint.BadRequestError}
     * @throws {@link Crossmint.ForbiddenError}
     * @throws {@link Crossmint.NotFoundError}
     * @throws {@link Crossmint.NotImplementedError}
     * @throws {@link Crossmint.ServiceUnavailableError}
     *
     * @example
     *     await client.nfTs.burnNftByLocator("polygon:0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045:52")
     */
    public async burnNftByLocator(
        locator: string,
        requestOptions?: NfTs.RequestOptions
    ): Promise<Crossmint.BurnNftResponse> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.CrossmintEnvironment.Default,
                `v1-alpha1/nfts/${encodeURIComponent(locator)}`
            ),
            method: "DELETE",
            headers: {
                "X-CLIENT-ID": await core.Supplier.get(this._options.clientId),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "crossmint",
                "X-Fern-SDK-Version": "0.0.6",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
            },
            contentType: "application/json",
            requestType: "json",
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return serializers.BurnNftResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                skipValidation: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Crossmint.BadRequestError(_response.error.body);
                case 403:
                    throw new Crossmint.ForbiddenError(_response.error.body);
                case 404:
                    throw new Crossmint.NotFoundError(_response.error.body);
                case 501:
                    throw new Crossmint.NotImplementedError(
                        serializers.NotImplementedErrorBody.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        })
                    );
                case 503:
                    throw new Crossmint.ServiceUnavailableError(_response.error.body);
                default:
                    throw new errors.CrossmintError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CrossmintError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CrossmintTimeoutError();
            case "unknown":
                throw new errors.CrossmintError({
                    message: _response.error.errorMessage,
                });
        }
    }

    /**
     * Edit a minted NFT's metadata using a Crossmint NFT locator.
     *
     * **API scope required**: `nfts.update`
     *
     * @param {string} locator - The locator of the NFT, which includes the blockchain, contract address, and token ID.
     * @param {Crossmint.EditNftByLocatorRequest} request
     * @param {NfTs.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Crossmint.BadRequestError}
     * @throws {@link Crossmint.ForbiddenError}
     * @throws {@link Crossmint.NotFoundError}
     * @throws {@link Crossmint.NotImplementedError}
     * @throws {@link Crossmint.ServiceUnavailableError}
     *
     * @example
     *     await client.nfTs.editNftByLocator("polygon:0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045:52", {
     *         metadata: {
     *             name: "Crossmint Example NFT",
     *             image: "https://www.crossmint.com/assets/crossmint/logo.png",
     *             description: "My NFT created via the mint API!"
     *         },
     *         reuploadLinkedFiles: true
     *     })
     */
    public async editNftByLocator(
        locator: string,
        request: Crossmint.EditNftByLocatorRequest,
        requestOptions?: NfTs.RequestOptions
    ): Promise<Crossmint.EditNftResponse> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.environment)) ?? environments.CrossmintEnvironment.Default,
                `v1-alpha1/nfts/${encodeURIComponent(locator)}`
            ),
            method: "PATCH",
            headers: {
                "X-CLIENT-ID": await core.Supplier.get(this._options.clientId),
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "crossmint",
                "X-Fern-SDK-Version": "0.0.6",
                "X-Fern-Runtime": core.RUNTIME.type,
                "X-Fern-Runtime-Version": core.RUNTIME.version,
                ...(await this._getCustomAuthorizationHeaders()),
            },
            contentType: "application/json",
            requestType: "json",
            body: serializers.EditNftByLocatorRequest.jsonOrThrow(request, { unrecognizedObjectKeys: "strip" }),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return serializers.EditNftResponse.parseOrThrow(_response.body, {
                unrecognizedObjectKeys: "passthrough",
                allowUnrecognizedUnionMembers: true,
                allowUnrecognizedEnumValues: true,
                skipValidation: true,
                breadcrumbsPrefix: ["response"],
            });
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Crossmint.BadRequestError(_response.error.body);
                case 403:
                    throw new Crossmint.ForbiddenError(_response.error.body);
                case 404:
                    throw new Crossmint.NotFoundError(_response.error.body);
                case 501:
                    throw new Crossmint.NotImplementedError(
                        serializers.NotImplementedErrorBody.parseOrThrow(_response.error.body, {
                            unrecognizedObjectKeys: "passthrough",
                            allowUnrecognizedUnionMembers: true,
                            allowUnrecognizedEnumValues: true,
                            skipValidation: true,
                            breadcrumbsPrefix: ["response"],
                        })
                    );
                case 503:
                    throw new Crossmint.ServiceUnavailableError(_response.error.body);
                default:
                    throw new errors.CrossmintError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.CrossmintError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                });
            case "timeout":
                throw new errors.CrossmintTimeoutError();
            case "unknown":
                throw new errors.CrossmintError({
                    message: _response.error.errorMessage,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const authorizationValue = await core.Supplier.get(this._options.authorization);
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { Authorization: authorizationValue, "X-API-KEY": apiKeyValue };
    }
}
